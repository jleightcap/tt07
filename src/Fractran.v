/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.3. DO NOT MODIFY.
*/
module Fractran
    ( // Inputs
      input  clk // clock
    , input  rst // reset
    , input  en // enable
    , input [17:0] accumulator

      // Outputs
    , output wire [7:0] degree
    , output wire  we
    , output wire  halt
    , output wire [5:0] count
    );
  // src/Fractran.hs:122:1-88
  reg [16:0] s1 = {1'd0,   {1'b1,{1'b1,8'b00000000}},   6'b000000};
  wire [7:0] c$case_alt_0;
  wire [7:0] c$app_arg;
  wire  c$app_arg_0;
  wire [0:0] c$app_arg_1;
  // src/Fractran.hs:107:1-6
  wire [7:0] a;
  wire [16:0] c$case_alt_1;
  wire [5:0] c$app_arg_2;
  // src/Fractran.hs:57:7-8
  wire [7:0] ipv;
  wire [9:0] c$case_alt_2;
  // src/Fractran.hs:57:7-8
  wire [7:0] a_0;
  reg [9:0] c$case_alt_3;
  wire [9:0] result;
  wire [9:0] c$case_alt_4;
  wire [9:0] result_0;
  // src/Fractran.hs:81:1-6
  wire [8:0] f;
  // src/Fractran.hs:81:1-6
  wire [8:0] a_1;
  wire [8:0] c$case_alt_selection_2;
  wire [9:0] c$app_arg_selection_1;
  wire [9:0] c$app_arg_selection_6;
  wire [0:0] c$case_alt_selection_res;
  wire [7:0] c$bv;
  wire [15:0] c$case_alt;

  // register begin
  always @(posedge clk or  posedge  rst) begin : s1_register
    if ( rst) begin
      s1 <= {1'd0,   {1'b1,{1'b1,8'b00000000}},   6'b000000};
    end else if (en) begin
      s1 <= c$case_alt_1;
    end
  end
  // register end

  assign c$case_alt_selection_2 = s1[14:6];

  assign c$case_alt_0 = c$case_alt_selection_2[8:8] ? a : 8'b00000000;

  assign c$app_arg_selection_1 = s1[15:6];

  assign c$app_arg = c$app_arg_selection_1[9:9] ? c$case_alt_0 : 8'b00000000;

  assign c$app_arg_0 = s1[16:16] ? (1'b1) : (1'b0);

  assign c$app_arg_selection_6 = s1[15:6];

  assign c$app_arg_1 = c$app_arg_selection_6[9:9] ? 1'b0 : 1'b1;

  assign c$case_alt = {c$app_arg,   c$app_arg_0,
                       (c$app_arg_1),   s1[5:0]};

  assign a = s1[13:6];

  assign c$case_alt_1 = s1[16:16] ? {1'd0,
                                     s1[15:6],   c$app_arg_2} : {1'd1,   result_0,
                                                                 c$app_arg_2};

  assign c$app_arg_2 = s1[5:0] + 6'b000001;

  assign ipv = f[7:0];

  assign c$case_alt_2 = a_1[8:8] ? {1'b1,{1'b1,a_0 + ipv}} : c$case_alt_3;

  assign a_0 = a_1[7:0];

  assign c$bv = (ipv);

  assign c$case_alt_selection_res = (( c$bv[8-1] ));

  always @(*) begin
    case(c$case_alt_selection_res)
      1'b1 : c$case_alt_3 = {1'b0,9'bxxxxxxxxx};
      default : c$case_alt_3 = {1'b1,{1'b1,ipv}};
    endcase
  end

  assign result = f[8:8] ? c$case_alt_2 : {1'b1,a_1};

  assign c$case_alt_4 = f[8:8] ? result : {1'b1,{1'b0,8'bxxxxxxxx}};

  assign result_0 = a_1[8:8] ? result : c$case_alt_4;

  assign f = accumulator[8:0];

  assign a_1 = accumulator[17:9];

  assign degree = c$case_alt[15:8];

  assign we = c$case_alt[7:7];

  assign halt = c$case_alt[6:6];

  assign count = c$case_alt[5:0];


endmodule

