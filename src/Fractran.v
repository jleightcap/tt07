/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.3. DO NOT MODIFY.
*/
module Fractran
    ( // Inputs
      input [7:0] accumulator
    , input [7:0] fraction
    , input  clk // clock
    , input  rst // reset
    , input  en // enable

      // Outputs
    , output wire [7:0] degree
    , output wire  we
    , output wire  halt
    , output wire [5:0] count
    );
  // src/Fractran.hs:146:1-9
  wire [17:0] \input ;
  // src/Fractran.hs:118:1-88
  reg [15:0] s1 = {1'd0,   {1'b1,8'b00000000},   6'b000000};
  wire  c$app_arg;
  wire [7:0] c$app_arg_0;
  // src/Fractran.hs:37:3-6
  wire [7:0] a;
  wire [15:0] result_0;
  wire [8:0] result_1;
  wire [8:0] c$case_alt;
  wire [8:0] c$case_alt_0;
  // src/Fractran.hs:56:7-8
  wire [7:0] ipv;
  // src/Fractran.hs:56:7-8
  wire [7:0] ipv_0;
  // src/Fractran.hs:79:1-6
  wire [8:0] f;
  // src/Fractran.hs:79:1-6
  wire [8:0] a_0;
  // src/Fractran.hs:146:1-9
  reg [8:0] c$input_app_arg;
  // src/Fractran.hs:146:1-9
  reg [8:0] c$input_app_arg_0;
  wire [8:0] c$app_arg_selection_3;
  wire [15:0] result;

  assign \input  = {c$input_app_arg_0,
                    c$input_app_arg};

  // register begin
  always @(posedge clk or  posedge  rst) begin : s1_register
    if ( rst) begin
      s1 <= {1'd0,   {1'b1,8'b00000000},   6'b000000};
    end else if (en) begin
      s1 <= result_0;
    end
  end
  // register end

  assign c$app_arg = s1[15:15] ? (1'b1) : (1'b0);

  assign c$app_arg_selection_3 = s1[14:6];

  assign c$app_arg_0 = c$app_arg_selection_3[8:8] ? (a) : 8'b11111111;

  assign a = s1[13:6];

  assign result_0 = s1[15:15] ? {1'd0,
                                 result_1,   s1[5:0]} : {1'd1,   result_1,
                                                         s1[5:0] + 6'b000001};

  assign result_1 = a_0[8:8] ? c$case_alt : c$case_alt_0;

  assign c$case_alt = f[8:8] ? {1'b1,ipv + ipv_0} : a_0;

  assign c$case_alt_0 = f[8:8] ? {1'b1,ipv_0} : {1'b0,8'bxxxxxxxx};

  assign ipv = a_0[7:0];

  assign ipv_0 = f[7:0];

  assign f = \input [8:0];

  assign a_0 = \input [17:9];

  assign result = {c$app_arg_0,   c$app_arg,
                   1'b0,   s1[5:0]};

  always @(*) begin
    case(fraction)
      8'b11111111 : c$input_app_arg = {1'b0,8'bxxxxxxxx};
      default : c$input_app_arg = {1'b1,fraction};
    endcase
  end

  always @(*) begin
    case(accumulator)
      8'b11111111 : c$input_app_arg_0 = {1'b0,8'bxxxxxxxx};
      default : c$input_app_arg_0 = {1'b1,accumulator};
    endcase
  end

  assign degree = result[15:8];

  assign we = result[7:7];

  assign halt = result[6:6];

  assign count = result[5:0];


endmodule

